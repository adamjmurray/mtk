grammar MTK_Grammar

  rule root
    ( space? root:(sequencer | bare_sequencer | timeline) space? ) {
      root.value
    }
  end

  rule bare_sequencer
    ( '' pattern ) {
      # it seems at least 2 elements are needed for me to access the pattern submatch,
      # so using an empty string as a workaround
      ::MTK::Sequencers.LegatoSequencer pattern.value
    }
  end

  rule sequencer
    ( left_curly bare_sequencer right_curly ) {
      bare_sequencer.value
    }
  end

  rule timeline
    ( left_curly timepoint pattern (space timepoint pattern)* right_curly ) {
      ::MTK::Timeline.from_a values(:timepoint).zip(values :pattern)
    }
  end

  rule pattern
    sequence | bare_sequence | chain
  end

  rule bare_sequence
    ( sequenceable (space sequenceable)* ) {
      ::MTK::Patterns.Sequence *values(:sequenceable)
    }
  end

  rule sequence
    ( left_paren bare_sequence right_paren ) {
      bare_sequence.value
    }
  end

  rule sequenceable
    chain | unchained
  end

  rule chain
    ( unchained ':' unchained (':' unchained)* ){
      ::MTK::Patterns.Chain *values(:unchained)
    }
  end

  rule unchained
    ( chord | intensity | duration | interval | pitch | pitch_class | sequence )
  end

  rule chord
    ( left_bracket pitch (space pitch)* right_bracket ) {
      ::MTK::Chord *values(:pitch)
    }
  end

  rule pitch
    ( pitch_class int ) {
      ::MTK::Pitch[pitch_class.value, int.value]
    }
  end

  rule pitch_class
    ( [A-Ga-g] [#b]*2 ) {
      ::MTK::PitchClass[to_s]
    }
  end

  rule interval
    ( [Pp] [1458] | ('maj'|'min'|[Mm]) [2367] | 'TT' | 'tt' ) {
      ::MTK::Interval.from_s(to_s)
    }
  end

  rule intensity
    ( ('p'1*3 | 'mp' | 'mf' | 'o' | 'f'2*3) ('+'|'-')? ) {
      ::MTK::Intensity.from_s(to_s)
    }
  end

  rule duration
    ( [whqisrx] ('.'|'t')* ) {
      ::MTK::Duration.from_s(to_s)
    }
  end

  rule timepoint
    ( number right_arrow ) {
      number.value
    }
  end

  rule number
    float | int
  end

  rule float
    ( '-'? [0-9]+ '.' [0-9]+ ) {
      to_f
    }
  end

  rule int
    ( '-'? [0-9]+ ) {
      to_i
    }
  end

  rule left_paren
    ( '(' space? ) { nil }
  end

  rule right_paren
    ( space? ')' ) { nil }
  end

  rule left_bracket
    ( '[' space? ) { nil }
  end

  rule right_bracket
    ( space? ']' )  { nil }
  end

  rule left_curly
    ( '{' space? ) { nil }
  end

  rule right_curly
    ( space? '}' ) { nil }
  end

  rule right_arrow
    ( space? '=>' space? ) { nil }
  end

  rule space
    [\s]+ { nil }
  end

end
