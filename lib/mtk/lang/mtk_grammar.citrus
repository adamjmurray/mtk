grammar MTK_Grammar
  include MTK

  rule root
    bare_sequence | pattern | timeline
  end

  rule bare_sequence
    ( sequenceable (space sequenceable)* ) {
      Patterns.Sequence *values(:sequenceable)
    }
  end

  rule timeline
    ( '{' space? number space? '=>' space? pattern (space number space? '=>' space? pattern)* space? '}' ) {
      Timeline.from_a values(:number).zip(values :pattern)
    }
  end

  rule sequencer
    ( '{' space? root space? '}' ) {
      Sequencers.LegatoSequencer *values(:root)
    }
  end

  rule pattern
    sequence | chain
  end

  rule sequence
    ( left_paren sequenceable (space sequenceable)* right_paren ) {
      Patterns.Sequence *values(:sequenceable)
    }
  end

  rule sequenceable
    chain | unchained
  end

  rule chain
    ( unchained ':' unchained (':' unchained)* ){
      Patterns.Chain *values(:unchained)
    }
  end

  rule unchained
    ( chord | intensity | duration | interval | pitch | pitch_class | sequence )
  end

  rule chord
    ( '[' space? pitch (space pitch)* space? ']' ) {
        Chord *values(:pitch)
    }
  end

  rule pitch
    ( pitch_class int ) {
      Pitch[pitch_class.value, int.value]
    }
  end

  rule pitch_class
    ( [A-Ga-g] [#b]*2 ) {
      PitchClass[to_s]
    }
  end

  rule interval
    ( [Pp] [1458] | ('maj'|'min'|[Mm]) [2367] | 'TT' | 'tt' ) {
      Interval.from_s(to_s)
    }
  end

  rule intensity
    ( ('p'1*3 | 'mp' | 'mf' | 'o' | 'f'2*3) ('+'|'-')? ) {
      Intensity.from_s(to_s)
    }
  end

  rule duration
    ( [whqisrx] ('.'|'t')* ) {
      Duration.from_s(to_s)
    }
  end

  rule number
    float | int
  end

  rule float
    ( '-'? [0-9]+ '.' [0-9]+ ) {
      to_f
    }
  end

  rule int
    ( '-'? [0-9]+ ) {
      to_i
    }
  end

  rule left_paren
    ( '(' space? ) { nil }
  end

  rule right_paren
    ( space? ')' ) { nil }
  end

  rule left_bracket
    ( '[' space? ) { nil }
  end

  rule right_bracket
    ( space? ']' )  { nil }
  end

  rule space
    [\s]+ { nil }
  end

end
