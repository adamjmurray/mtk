grammar MTK_Grammar

  rule root
    ( space? root:(bare_sequencer | sequencer | timeline) space? ) {
      root.value
    }
  end

  rule bare_sequencer
    ( pattern '' ) {
      # it seems at least 2 elements are needed to access the pattern submatch,
      # so using an empty string as a workaround
      ::MTK::Sequencers.LegatoSequencer pattern.value
    }
  end

  rule sequencer
    ( left_curly bare_sequencer right_curly ) {
      bare_sequencer.value
    }
  end

  rule timeline
    ( left_curly timepoint pattern (space timepoint pattern)* right_curly ) {
      ::MTK::Timeline.from_a values_of(:timepoint).zip(values_of :pattern)
    }
  end

  rule pattern
    ( pattern:(bare_choice | choice) '' ) {
      val = first.value
      if val.is_a? ::MTK::Patterns::Pattern then val else ::MTK::Patterns::Pattern.new [val] end
    }
  end


  rule bare_choice
    (
      seq:(bare_sequence | sequence) (pipe seq:(bare_sequence | sequence))*
    )
    {
      vals = values_of :seq
      if vals.length==1 then vals[0] else ::MTK::Patterns.Choice(*vals) end
    }
  end


  rule choice
    (
      left_angle bare_choice right_angle
    )
    {
      bare_choice.value
    }
  end


  rule bare_sequence
    (
      chain (space chain)*
    )
    {
      vals = values_of :chain
      if vals.length==1 then vals[0] else ::MTK::Patterns.Sequence(*vals) end
    }
  end


  rule sequence # or cycle depending on the presence of the max_cycles option
    (
      left_paren chain (space chain)* right_paren ('*' max_cycles:int)? ('&' max_elements:int)?
    )
    {
      chains = values_of(:chain)
      options = max_elements ? {max_elements: max_elements.value} : {}

      if max_cycles
        options[:max_cycles] = max_cycles.value
        ::MTK::Patterns::Cycle.new chains, options

      elsif chains.length > 1 || max_elements
        ::MTK::Patterns::Sequence.new chains, options

      else
        vals[0] # Don't form a sequence unnecessarily
      end
    }
  end


  rule chain
    ( chainable (':' chainable)* ) {
      vals = values_of(:chainable)
      vals.length == 1 ? vals[0] : ::MTK::Patterns.Chain(*vals)
    }
  end

  rule chainable
    ( choice | sequence | chord | intensity | duration | interval | pitch | pitch_class )
  end

  rule chord
    ( left_bracket pitch (space pitch)* right_bracket ) {
      ::MTK::Chord *values_of(:pitch)
    }
  end

  rule pitch
    ( pitch_class int ) {
      ::MTK::Pitch[pitch_class.value, int.value]
    }
  end

  rule pitch_class
    ( [A-Ga-g] [#b]*2 ) {
      ::MTK::PitchClass[to_s]
    }
  end

  rule interval
    ( [Pp] [1458] | ('maj'|'min'|[Mm]) [2367] | 'TT' | 'tt' ) {
      ::MTK::Interval.from_s(to_s)
    }
  end

  rule intensity
    ( ('p'1*3 | 'mp' | 'mf' | 'o' | 'f'2*3) ('+'|'-')? ) {
      ::MTK::Intensity.from_s(to_s)
    }
  end

  rule duration
    ( [whqisrx] ('.'|'t')* ) {
      ::MTK::Duration.from_s(to_s)
    }
  end

  rule timepoint
    ( number right_arrow ) {
      number.value
    }
  end

  rule number
    float | int
  end

  rule float
    ( '-'? [0-9]+ '.' [0-9]+ ) {
      to_f
    }
  end

  rule int
    ( '-'? [0-9]+ ) {
      to_i
    }
  end

  rule left_paren
    ( '(' space? ) { nil }
  end

  rule right_paren
    ( space? ')' ) { nil }
  end

  rule left_bracket
    ( '[' space? ) { nil }
  end

  rule right_bracket
    ( space? ']' )  { nil }
  end

  rule left_curly
    ( '{' space? ) { nil }
  end

  rule right_curly
    ( space? '}' ) { nil }
  end

  rule left_angle
    ( '<' space? ) { nil }
  end

  rule right_angle
    ( space? '>' )  { nil }
  end

  rule pipe
    ( space? '|' space? ) { nil }
  end

  rule right_arrow
    ( space? '=>' space? ) { nil }
  end

  rule space
    [\s]+ { nil }
  end

end
