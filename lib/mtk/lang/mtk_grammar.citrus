grammar MTK_Grammar

  rule root
    ( space? root:(bare_sequencer | sequencer) space? ) {
      root.value
    }
  end

  rule bare_sequencer
    ( pattern '' ) {
      # it seems at least 2 elements are needed to access the pattern submatch,
      # so using an empty string as a workaround
      MTK::Sequencers.LegatoSequencer pattern.value
    }
  end

  rule sequencer
    ( left_curly bare_sequencer right_curly ) {
      bare_sequencer.value
    }
  end

  rule pattern
    ( pattern:(bare_choice | choice) '' ) {
      val = first.value
      if val.is_a? MTK::Patterns::Pattern then val else MTK::Patterns::Sequence.new [val] end
    }
  end


  rule bare_choice
    (
      seq:(bare_sequence | sequence) (pipe seq:(bare_sequence | sequence))*
    )
    {
      vals = values_of :seq
      if vals.length==1 then vals[0] else MTK::Patterns.Choice(*vals) end
    }
  end


  rule choice
    (
      left_angle bare_choice right_angle
    )
    {
      bare_choice.value
    }
  end


  rule bare_sequence
    (
      chain (space chain)*
    )
    {
      vals = values_of :chain
      if vals.length==1 then vals[0] else MTK::Patterns.Sequence(*vals) end
    }
  end


  rule sequence
    (
      left_paren chain (space chain)* right_paren ('*' max_cycles:int)? ('&' element_count:int)?
    )
    {
      chains = values_of(:chain)
      options = {}
      if element_count
        options[:min_elements] = options[:max_elements] = element_count.value
      end
      options[:max_cycles] = max_cycles.value if max_cycles
      if chains.length == 1 and options.empty?
        chains[0] # Don't form a chain unnecessarily
      else
        MTK::Patterns::Sequence.new chains, options
      end
    }
  end


  rule for_each
    (
      sequence ('#' sequence)+
    )
    {
      MTK::Patterns::ForEach.new(values_of :sequence)
    }
  end


  rule chain
    ( chainable (':' chainable)* ) {
      vals = values_of(:chainable)
      vals.length == 1 ? vals[0] : MTK::Patterns.Chain(*vals)
    }
  end

  rule chainable
    ( for_each | choice | sequence | element )
  end

  rule element
    (
      elem:( intensity | duration | relative_chord | interval | pitch | pitch_class | variable | modifier ) ('*' max_cycles:int)?
    )
    {
      if max_cycles
        MTK::Patterns::Sequence.new( [elem.value], max_cycles: max_cycles.value )
      else
        elem.value
      end
    }
  end

  rule variable
    ( predefined_scale | scale | scale_element | arpeggio | arpeggio_element | for_each_element )
  end

  rule predefined_scale
    (
      '$' left_bracket pitch_class space scale_name:( [A-Za-z][A-Za-z]+ (space [A-Za-z][A-Za-z]+)? ) right_bracket
    )
    {
      scale_intervals = MTK::Lang::IntervalGroups.find_scale(scale_name)
      raise "Invalid scale name #{scale_name}" unless scale_intervals
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE, to_s, MTK.PitchClassGroup(scale_intervals.to_pitch_classes(pitch_class.value)))
    }
  end

  rule scale
    (
      '$' left_bracket pitch_class (space pitch_class)* right_bracket
    )
    {
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE, to_s, MTK.PitchClassGroup(values_of :pitch_class))
    }
  end

  rule scale_element
    ( scale_index | scale_increment | scale_random )
  end

  rule arpeggio
    ( pitch_arpeggio | relative_chord_arpeggio )
  end

  rule pitch_arpeggio
    (
      '@' left_bracket pitch (space pitch)* right_bracket
    )
    {
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO, to_s, MTK.PitchGroup(values_of :pitch))
    }
  end

  rule relative_chord_arpeggio
    (
      '@' relative_chord
    )
    {
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO, to_s, relative_chord.value)
    }
  end

  rule arpeggio_element
    ( arpeggio_index | arpeggio_increment | arpeggio_random | arpeggio_all )
  end

  rule relative_chord
    ( 'i' [vx] | 'I' [VX] | [iI]1*3 | 'v' 'i'0*3 | 'V' 'I'0*3 )
    {
      MTK::Groups::RelativeChord.from_s(to_s)
    }
  end

  rule pitch
    ( pitch_class int ) {
      MTK::Core::Pitch[pitch_class.value, int.value]
    }
  end

  rule pitch_class
    ( diatonic_pitch_class accidental? ) {
      MTK::Core::PitchClass[to_s]
    }
  end

  rule diatonic_pitch_class
    ( [A-G] ) {
      MTK::Core::PitchClass[to_s]
    }
  end

  rule accidental
    ('#'1*2 | 'b'1*2)
  end

  rule interval
    ('-'? ( 'P' [1458] | [Mm] [2367] | 'a' [1-7] | 'd' [2-8] | 'TT' )) {
      MTK::Core::Interval.from_s(to_s)
    }
  end

  rule intensity
    ( ('p'1*3 | 'mp' | 'mf' | 'f'1*3) ('+'|'-')? ) {
      MTK::Core::Intensity.from_s(to_s)
    }
  end

  rule duration
    ( rest:'-'? multiplier:number? [whqesrx] ('.'|'t')* ) {
      MTK::Core::Duration.from_s(to_s)
    }
  end
    
  rule scale_index
    ( '$' int ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE_ELEMENT, :index, int.value)
    }
  end

  rule scale_increment
    ( '$' increment:('+'+ | '-'+) ) {
      inc = increment.to_s
      value = (if inc =~ /\+/ then inc.size else -inc.size end)
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE_ELEMENT, :increment, value)
    }
  end

  rule scale_random
    ( '$?' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE_ELEMENT, :random)
    }
  end

  rule scale_all
    ( '$!' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::SCALE_ELEMENT, :all)
    }
  end

  rule arpeggio_index
    ( prefix:('@' '%'?) int ) {
      name = (if prefix.to_s == '@' then :index else :modulo_index end)
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO_ELEMENT, name, int.value)
    }
  end

  rule arpeggio_increment
    ( prefix:('@' '%'?) increment:('+'+ | '-'+) ) {
      name = (if prefix.to_s == '@' then :increment else :modulo_increment end)
      inc = increment.to_s
      value = (if inc =~ /\+/ then inc.size else -inc.size end)
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO_ELEMENT, name, value)
    }
  end

  rule arpeggio_random
    ( '@?' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO_ELEMENT, :random)
    }
  end

  rule arpeggio_all
    ( '@!' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::ARPEGGIO_ELEMENT, :all)
    }
  end

  rule for_each_element
    ( for_each_index | for_each_random | for_each_all )
  end

  rule for_each_index
    ( '#' int ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::FOR_EACH_ELEMENT, :index, int.value)
    }
  end

  rule for_each_random
    ( '#?' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::FOR_EACH_ELEMENT, :random)
    }
  end

  rule for_each_all
    ( '#!' ) {
      MTK::Lang::Variable.new(MTK::Lang::Variable::FOR_EACH_ELEMENT, :all)
    }
  end

  rule modifier
    ( '_' ) {
      MTK::Lang::Modifier.new(:force_rest)
    }
  end


  rule number
    float | rational | int
  end

  rule float
    ( '-'? [0-9]+ '.' [0-9]+ ) {
      to_f
    }
  end

  rule rational
    ( numerator:int '/' denominator:[0-9]+ ) {
      Rational(numerator.value, denominator.to_i)
    }
  end

  rule int
    ( '-'? [0-9]+ ) {
      to_i
    }
  end

  rule left_paren
    ( '(' space? ) { nil }
  end

  rule right_paren
    ( space? ')' ) { nil }
  end

  rule left_bracket
    ( '[' space? ) { nil }
  end

  rule right_bracket
    ( space? ']' )  { nil }
  end

  rule left_curly
    ( '{' space? ) { nil }
  end

  rule right_curly
    ( space? '}' ) { nil }
  end

  rule left_angle
    ( '<' space? ) { nil }
  end

  rule right_angle
    ( space? '>' )  { nil }
  end

  rule pipe
    ( space? '|' space? ) { nil }
  end

  rule right_arrow
    ( space? '=>' space? ) { nil }
  end

  rule space
    [\s]+ { nil }
  end

end
