#!/usr/bin/env ruby

require 'mtk'
require 'optparse'

options = {}

option_parser = OptionParser.new do |opts|

  opts.banner = "Usage: #{$0} [options]"
  opts.separator ''
  opts.separator 'Options:'

  opts.on('-p FILE', '--play FILE', 'play or print the contents of a MIDI file',
          'if no --output is specified, print the MIDI file') {|file| options[:play] = file }

  opts.separator ''

  opts.on('-c FILE', '--convert FILE', 'convert a file containing MTK syntax to MIDI',
          'if a --file is given, write the MIDI to a file',
          'if an --output is given, play the MIDI',
          'otherwise print the MIDI') {|file| options[:convert] = file }

  opts.separator ''

  opts.on('-e [syntax]', '--evaluate [syntax]', 'convert the given MTK syntax String to MIDI',
          'if no [syntax] is given, starts an interactive interpreter',
          'if a --file is given, write the MIDI to a file',
          'if an --output is given, play the MIDI',
          'otherwise print the MIDI') {|syntax| options[:interpret] = syntax }

  opts.separator ''

  opts.on('-f FILE', '--file FILE', 'write the output of --convert or --record to a file') {|file| options[:file] = file }

  opts.separator ''

  opts.on('-l', '--list', 'list available MIDI devices for --record and --output') { options[:list] = true }

  opts.separator ''

  opts.on('-r INPUT', '--record INPUT', 'record MIDI input',
          'if no --file is specified, prints the recorded MIDI') {|input| options[:record] = input }

  opts.separator ''

  opts.on('-o OUTPUT', '--output OUTPUT', 'set MIDI output for playing') {|output| options[:output] = output }

  opts.separator ''

  opts.on('-t', '--tutorial', 'Start an interactive tutorial for the MTK syntax') { options[:tutorial] = true }

  opts.separator ''

  opts.on('-h', '--help', 'Show this message') { puts opts; exit }

end


puts option_parser and exit if ARGV.length == 0
#p ARGV
#p options
begin
  option_parser.parse!
rescue OptionParser::MissingArgument, OptionParser::InvalidOption
  puts "Invalid command, #{$!}"
  puts "For command line help: #{$0} --help"
end


def setup_io
  require 'mtk/midi/output'

  # TODO: update inputs to automatically handle this like in MTK::MIDI::Output
  if RUBY_PLATFORM == 'java'
    require 'mtk/midi/jsound_input'
    @inputs  = MTK::MIDI::JSoundInput
  else
    require 'mtk/midi/unimidi_input'
    @inputs  = MTK::MIDI::UniMIDIInput
  end
end


def convert(mtk_syntax)
  require 'mtk/lang/grammar'
  sequencer = MTK::Lang::Grammar.parse(mtk_syntax)
  timeline = sequencer.to_timeline
  output(timeline)
end


def output(timelines, print_header='Timeline')
  timelines = [timelines] unless timelines.is_a? Array
  if @output
    @output.play timelines.first # TODO: support multiple timelines
  else
    puts print_header, timelines
  end
end



if options[:list]
  setup_io
  input_names  = @inputs.devices
  output_names = MTK::MIDI::Output.devices
  puts
  puts (['INPUTS:'] + input_names).join("\n * ")
  puts
  puts (['OUTPUTS:']+output_names).join("\n * ")
  puts
  puts 'When specifying --record INPUT or --output OUTPUT, the first substring match will be used.'
  puts "For example: --output IAC will use 'Apple Inc. IAC Driver' if it's the first OUTPUT containing 'IAC'"
  puts
  exit
end


if options[:output]
  setup_io
  output_name = options[:output]
  @output = MTK::MIDI::Output.find_by_name /#{output_name}/
  if @output
    puts "Using output '#{@output.name}'"
  else
    STDERR.puts "#{output_name} not found."
    exit 2
  end
end


if options[:play]
  filename = options[:play]
  require 'mtk/midi/file'
  timelines = MTK::MIDI_File(filename).to_timelines
  output(timelines, "Timeline for #{filename}")
end


if options.has_key? :interpret
  mtk_syntax = options[:interpret]
  if mtk_syntax.nil?
    puts "TODO: interactive interpreter"
  else
    convert(mtk_syntax)
  end
end


if options[:convert]
  mtk_syntax_file = options[:convert]
  mtk_syntax = IO.read(mtk_syntax_file)
  convert(mtk_syntax)
end


if options.has_key? :tutorial
  puts "TODO: tutorial"
end

if options[:record]
  puts "TODO: recording feature"
end

if options[:file]
  puts "TODO: file output"
end