#!/usr/bin/env ruby

require 'mtk'
require 'optparse'

options = {}

option_parser = OptionParser.new do |opts|

  opts.banner = "Usage: #{$0} [options]"
  opts.separator ''
  opts.separator 'Options:'

   opts.on('-c FILE', '--convert FILE', 'convert a file containing MTK syntax to MIDI',
          'if a --file is given, write the MIDI to a file',
          'if an --output is given, play the MIDI',
          'otherwise print the MIDI') {|file| options[:convert] = file }

  opts.separator ''

  opts.on('-e [syntax]', '--evaluate [syntax]', 'convert the given MTK syntax String to MIDI',
          'if no [syntax] is given, starts an interactive interpreter',
          'if a --file is given, write the MIDI to a file',
          'if an --output is given, play the MIDI',
          'otherwise print the MIDI') {|syntax| options[:interpret] = syntax }

  opts.separator ''

  opts.on('-f FILE', '--file FILE', 'write the output of --convert or --record to a file') {|file| options[:file] = file }

  opts.separator ''

  opts.on('-h', '--help', 'Show this message') { puts opts; exit }

  opts.separator ''

  opts.on('-i INPUT', '--input INPUT', 'set MIDI input for recording',
          'if no --file is specified, prints the recorded MIDI') {|input| options[:input] = input }

  opts.separator ''

  opts.on('-l', '--list', 'list available MIDI devices for --record and --output') { options[:list] = true }

  opts.separator ''

  opts.on('-m', '--monitor', 'monitor MIDI input while recording') { options[:monitor] = true }

  opts.separator ''

  opts.on('-o OUTPUT', '--output OUTPUT', 'set MIDI output for playing') {|output| options[:output] = output }

  opts.separator ''

  opts.on('-p FILE', '--play FILE', 'play or print the contents of a MIDI file',
          'if no --output is specified, print the MIDI file') {|file| options[:play] = file }

  opts.separator ''

  opts.on('-t', '--tutorial', 'Start an interactive tutorial for the MTK syntax') { options[:tutorial] = true }

  opts.separator ''

end


puts option_parser and exit if ARGV.length == 0
#p ARGV
#p options


ERROR_INVALID_COMMAND  = 1
ERROR_FILE_NOT_FOUND   = 2
ERROR_OUTPUT_NOT_FOUND = 3
ERROR_INPUT_NOT_FOUND  = 4


begin
  option_parser.parse!
rescue OptionParser::MissingArgument, OptionParser::InvalidOption
  puts "Invalid command, #{$!}"
  puts "For command line help: #{$0} --help"
  exit ERROR_INVALID_COMMAND
end


def setup_io
  require 'mtk/midi/input'
  require 'mtk/midi/output'
end


def convert(mtk_syntax)
  sequencer = MTK::Lang::Parser.parse(mtk_syntax)
  timeline = sequencer.to_timeline
  output(timeline)
end


def output(timelines, print_header='Timeline')
  timelines = [timelines] unless timelines.is_a? Array
  if @output
    @output.play timelines.first # TODO: support multiple timelines
  else
    puts print_header, timelines
  end
end


def record
  if @input
    print "Press Enter to begin recording MIDI input..."
    gets
    puts "Recording input. Press control-C to stop."
    @input.record monitor:@monitor
    Signal.trap("INT") do # SIGINT = control-C
      @input.stop
      puts
      puts "Recorded MIDI data"
      puts @input.to_timeline
      exit
    end
    loop{ sleep 0.001 }
  end
end



if options[:list]
  setup_io
  input_names  = MTK::MIDI::Input.devices_by_name.keys
  output_names = MTK::MIDI::Output.devices_by_name.keys
  puts
  puts (['INPUTS:'] + input_names).join("\n * ")
  puts
  puts (['OUTPUTS:']+output_names).join("\n * ")
  puts
  puts 'When specifying --record INPUT or --output OUTPUT, the first substring match will be used.'
  puts "For example: --output IAC will use 'Apple Inc. IAC Driver' if it's the first OUTPUT containing 'IAC'"
  puts
  exit
end

@monitor = true if options[:monitor]

if options[:output]
  setup_io
  output_name = options[:output]
  @output = MTK::MIDI::Output.find_by_name /#{output_name}/
  if @output
    puts "Using output '#{@output.name}'"
  else
    STDERR.puts "Output '#{output_name}' not found."
    exit ERROR_OUTPUT_NOT_FOUND
  end
end


if options[:play]
  filename = options[:play]
  require 'mtk/midi/file'
  timelines = MTK::MIDI_File(filename).to_timelines
  output(timelines, "Timeline for #{filename}")
end


if options.has_key? :interpret
  mtk_syntax = options[:interpret]
  if mtk_syntax.nil?
    puts "TODO: interactive interpreter"
  else
    convert(mtk_syntax)
  end
end


if options[:convert]
  mtk_syntax_file = options[:convert]
  mtk_syntax = IO.read(mtk_syntax_file)
  convert(mtk_syntax)
end


if options.has_key? :tutorial
  puts "TODO: tutorial"
end

if options[:input]
  setup_io
  input_name = options[:input]
  @input = MTK::MIDI::Input.find_by_name /#{input_name}/
  if @input
    puts "Using input '#{@input.name}'"
  else
    STDERR.puts "Input '#{input_name}' not found."
    exit ERROR_INPUT_NOT_FOUND
  end
end

if options[:file]
  puts "TODO: file output"
end


record if @input
